use anyhow::Result;
use petgraph::graph::NodeIndex;
use petgraph::visit::EdgeRef;
use std::collections::HashMap;
use std::fs;
use std::path::Path;

use crate::core::{DependencyGraph, Edge, EdgeType, Node, NodeType};

mod json_compact;
mod llm_language;
mod llm_optimized;

pub use json_compact::JsonCompactFormatter;
pub use llm_language::{LlmLanguageAdapter, PythonLanguageAdapter};
pub use llm_optimized::LLMOptimizedFormatter;

pub struct EmbargoFormatter;

impl EmbargoFormatter {
    pub fn new() -> Self {
        Self
    }

    pub fn format_to_file(&self, graph: &DependencyGraph, output_path: &Path) -> Result<()> {
        let formatted_content = self.format_graph(graph)?;
        fs::write(output_path, formatted_content)?;
        Ok(())
    }

    fn format_graph(&self, graph: &DependencyGraph) -> Result<String> {
        let mut output = String::new();

        output.push_str("# EMBARGO - Codebase Dependency Analysis\n\n");
        output.push_str("Generated by embargo - An ultrafast codebase dependency extractor\n\n");
        output.push_str("## Overview\n\n");
        output.push_str(&format!("- **Total Nodes**: {}\n", graph.node_count()));
        output.push_str(&format!("- **Total Edges**: {}\n", graph.edge_count()));
        output.push_str("\n---\n\n");

        let node_indices: Vec<NodeIndex> = graph.node_indices().collect();

        let mut modules = Vec::new();
        let mut classes = Vec::new();
        let mut functions = Vec::new();
        let mut interfaces = Vec::new();
        let mut variables = Vec::new();

        for &node_idx in &node_indices {
            if let Some(node) = graph.node_weight(node_idx) {
                match node.node_type {
                    NodeType::Module => modules.push((node_idx, node)),
                    NodeType::Class => classes.push((node_idx, node)),
                    NodeType::Function => functions.push((node_idx, node)),
                    NodeType::Interface => interfaces.push((node_idx, node)),
                    NodeType::Variable => variables.push((node_idx, node)),
                    _ => {}
                }
            }
        }

        if !modules.is_empty() {
            output.push_str("## Modules & Imports\n\n");
            for (idx, module) in modules {
                output.push_str(&self.format_module_node(module, idx, graph));
            }
            output.push_str("\n---\n\n");
        }

        if !classes.is_empty() {
            output.push_str("## Classes\n\n");
            for (idx, class) in classes {
                output.push_str(&self.format_class_node(class, idx, graph));
            }
            output.push_str("\n---\n\n");
        }

        if !interfaces.is_empty() {
            output.push_str("## Interfaces\n\n");
            for (idx, interface) in interfaces {
                output.push_str(&self.format_interface_node(interface, idx, graph));
            }
            output.push_str("\n---\n\n");
        }

        if !functions.is_empty() {
            output.push_str("## Functions\n\n");
            for (idx, function) in functions {
                output.push_str(&self.format_function_node(function, idx, graph));
            }
            output.push_str("\n---\n\n");
        }

        if !variables.is_empty() {
            output.push_str("## Variables\n\n");
            for (idx, variable) in variables {
                output.push_str(&self.format_variable_node(variable, idx, graph));
            }
            output.push_str("\n---\n\n");
        }

        output.push_str("## Dependency Graph Summary\n\n");
        output.push_str("### Edge Types\n\n");

        let mut edge_counts = HashMap::new();
        for edge_ref in graph.edge_references() {
            let edge_type = &edge_ref.weight().edge_type;
            *edge_counts.entry(format!("{:?}", edge_type)).or_insert(0) += 1;
        }

        for (edge_type, count) in edge_counts {
            output.push_str(&format!("- **{}**: {} connections\n", edge_type, count));
        }

        output.push_str("\n### Dependency Analysis\n\n");
        output.push_str(
            "This dependency graph represents the relationships between code elements:\n\n",
        );
        output.push_str("- **Import**: Module import relationships\n");
        output.push_str("- **Call**: Function call relationships\n");
        output.push_str("- **Inheritance**: Class inheritance relationships\n");
        output.push_str("- **Implements**: Interface implementation relationships\n");
        output.push_str("- **Uses**: General usage relationships\n");
        output.push_str("- **Contains**: Containment relationships (class contains method)\n\n");

        output.push_str("---\n\n");
        output.push_str("*Generated by embargo - Optimize for LLM consumption and agentic software development*\n");

        Ok(output)
    }

    fn format_module_node(&self, node: &Node, idx: NodeIndex, graph: &DependencyGraph) -> String {
        let mut output = String::new();
        output.push_str(&format!("### {}\n\n", node.name));
        output.push_str(&format!("- **ID**: `{}`\n", node.id));
        output.push_str(&format!("- **File**: `{}`\n", node.file_path.display()));
        output.push_str(&format!("- **Line**: {}\n", node.line_number));
        output.push_str(&format!("- **Language**: {}\n", node.language));

        let dependencies = self.get_outgoing_edges(idx, graph);
        if !dependencies.is_empty() {
            output.push_str("\n**Dependencies**:\n");
            for (edge, target) in dependencies {
                output.push_str(&format!("- {:?}: `{}`\n", edge.edge_type, target.name));
            }
        }

        output.push_str("\n");
        output
    }

    fn format_class_node(&self, node: &Node, idx: NodeIndex, graph: &DependencyGraph) -> String {
        let mut output = String::new();
        output.push_str(&format!("### {}\n\n", node.name));
        output.push_str(&format!("- **ID**: `{}`\n", node.id));
        output.push_str(&format!("- **File**: `{}`\n", node.file_path.display()));
        output.push_str(&format!("- **Line**: {}\n", node.line_number));
        output.push_str(&format!("- **Language**: {}\n", node.language));

        if let Some(ref visibility) = node.visibility {
            output.push_str(&format!("- **Visibility**: {}\n", visibility));
        }

        if let Some(ref docstring) = node.docstring {
            output.push_str(&format!(
                "- **Documentation**:\n  ```\n  {}\n  ```\n",
                docstring
            ));
        }

        let outgoing = self.get_outgoing_edges(idx, graph);
        let incoming = self.get_incoming_edges(idx, graph);

        if !outgoing.is_empty() {
            output.push_str("\n**Extends/Implements**:\n");
            for (edge, target) in outgoing {
                output.push_str(&format!("- {:?}: `{}`\n", edge.edge_type, target.name));
            }
        }

        if !incoming.is_empty() {
            output.push_str("\n**Contains**:\n");
            for (edge, source) in incoming {
                if matches!(edge.edge_type, EdgeType::Contains) {
                    output.push_str(&format!(
                        "- {}: `{}`\n",
                        source.node_type.format(),
                        source.name
                    ));
                }
            }
        }

        output.push_str("\n");
        output
    }

    fn format_interface_node(
        &self,
        node: &Node,
        idx: NodeIndex,
        graph: &DependencyGraph,
    ) -> String {
        let mut output = String::new();
        output.push_str(&format!("### {}\n\n", node.name));
        output.push_str(&format!("- **ID**: `{}`\n", node.id));
        output.push_str(&format!("- **File**: `{}`\n", node.file_path.display()));
        output.push_str(&format!("- **Line**: {}\n", node.line_number));
        output.push_str(&format!("- **Language**: {}\n", node.language));

        let incoming = self.get_incoming_edges(idx, graph);
        if !incoming.is_empty() {
            output.push_str("\n**Implemented by**:\n");
            for (edge, source) in incoming {
                if matches!(edge.edge_type, EdgeType::Implements) {
                    output.push_str(&format!("- `{}`\n", source.name));
                }
            }
        }

        output.push_str("\n");
        output
    }

    fn format_function_node(&self, node: &Node, idx: NodeIndex, graph: &DependencyGraph) -> String {
        let mut output = String::new();
        output.push_str(&format!("### {}\n\n", node.name));
        output.push_str(&format!("- **ID**: `{}`\n", node.id));
        output.push_str(&format!("- **File**: `{}`\n", node.file_path.display()));
        output.push_str(&format!("- **Line**: {}\n", node.line_number));
        output.push_str(&format!("- **Language**: {}\n", node.language));

        if let Some(ref signature) = node.signature {
            output.push_str(&format!("- **Signature**: `{}`\n", signature));
        }

        if let Some(ref visibility) = node.visibility {
            output.push_str(&format!("- **Visibility**: {}\n", visibility));
        }

        if let Some(ref docstring) = node.docstring {
            output.push_str(&format!(
                "- **Documentation**:\n  ```\n  {}\n  ```\n",
                docstring
            ));
        }

        let outgoing = self.get_outgoing_edges(idx, graph);
        if !outgoing.is_empty() {
            output.push_str("\n**Calls**:\n");
            for (edge, target) in outgoing {
                if matches!(edge.edge_type, EdgeType::Call) {
                    output.push_str(&format!("- `{}`\n", target.name));
                }
            }
        }

        output.push_str("\n");
        output
    }

    fn format_variable_node(
        &self,
        node: &Node,
        _idx: NodeIndex,
        _graph: &DependencyGraph,
    ) -> String {
        let mut output = String::new();
        output.push_str(&format!("### {}\n\n", node.name));
        output.push_str(&format!("- **ID**: `{}`\n", node.id));
        output.push_str(&format!("- **File**: `{}`\n", node.file_path.display()));
        output.push_str(&format!("- **Line**: {}\n", node.line_number));
        output.push_str(&format!("- **Language**: {}\n", node.language));

        if let Some(ref visibility) = node.visibility {
            output.push_str(&format!("- **Visibility**: {}\n", visibility));
        }

        output.push_str("\n");
        output
    }

    fn get_outgoing_edges<'a>(
        &self,
        node_idx: NodeIndex,
        graph: &'a DependencyGraph,
    ) -> Vec<(&'a Edge, &'a Node)> {
        let mut edges = Vec::new();
        for edge_ref in graph.edges(node_idx) {
            let target_idx = edge_ref.target();
            let edge_weight = edge_ref.weight();
            if let Some(target_node) = graph.node_weight(target_idx) {
                edges.push((edge_weight, target_node));
            }
        }
        edges
    }

    fn get_incoming_edges<'a>(
        &self,
        node_idx: NodeIndex,
        graph: &'a DependencyGraph,
    ) -> Vec<(&'a Edge, &'a Node)> {
        let mut edges = Vec::new();
        for edge_ref in graph.edges_directed(node_idx, petgraph::Direction::Incoming) {
            let source_idx = edge_ref.source();
            let edge_weight = edge_ref.weight();
            if let Some(source_node) = graph.node_weight(source_idx) {
                edges.push((edge_weight, source_node));
            }
        }
        edges
    }
}

trait NodeTypeFormat {
    fn format(&self) -> &str;
}

impl NodeTypeFormat for NodeType {
    fn format(&self) -> &str {
        match self {
            NodeType::Module => "Module",
            NodeType::Class => "Class",
            NodeType::Function => "Function",
            NodeType::Variable => "Variable",
            NodeType::Interface => "Interface",
            NodeType::Enum => "Enum",
        }
    }
}
